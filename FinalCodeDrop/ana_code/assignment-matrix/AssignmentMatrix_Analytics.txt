// import the necessay modules
import org.apache.spark.SparkContext
import org.apache.spark.SparkContext._
import org.apache.spark.SparkConf
import org.apache.spark.sql.SQLContext

// read in data sources as datasets
val user_data = spark.read.format("org.apache.spark.csv").option("header", false).option("inferSchema", true).csv("dataset/assignment_matrix/data.csv")
val movies = spark.read.format("org.apache.spark.csv").option("header", false).option("inferSchema", true).csv("dataset/assignment_matrix/movie_titles.csv")

// create temporary tables from the datasets
user_data.registerTempTable("data")
movies.registerTempTable("movies")

// combine the datasets
val agg = spark.sql("SELECT data._c0 as movieID, data._c1 as userID, data._c2 as userRating, data._c3 as ratingDate, movies._c1 as movieReleaseYear, movies._c2 as movieTitle FROM data LEFT JOIN movies ON data._c0 = movies._c0")
agg.registerTempTable("aggregatedMovieData")

// cache dataframe to speed up performance
agg.cache()

// check number of records
agg.count()

// check data types of columns
agg.dtypes.foreach(println)

// calculate and record the average annual rating for each movie (if the movie has rating within the time frame)
val annualRating = spark.sql("SELECT YEAR(ratingDate) as Year, movieTitle, AVG(userRating) as avgRating, COUNT(*) as numRating FROM aggregatedMovieData GROUP BY Year, movieTitle ORDER BY Year ASC")

// calculate and record the average rating for each year
val annualAVG = spark.sql("SELECT Year, SUM(avgRating * numRating) / SUM(numRating) AS unweightedAVG FROM annualRating GROUP BY Year ORDER BY Year ASC")

// create temporary table from the dataframe
annualRating.registerTempTable("annualRating")

// save data to csv on hdfs
agg.write.option("header", "true").csv("aggregatedMovieData.csv")
annualRating.write.option("header", "true").csv("annualRating.csv")
annualAVG.write.option("header", "true").csv("annualAVG.csv")